library(tidyr)
library(ggplot2)
load("../read_data/data-NED2005.RData")
# organize data for model
i.species <- 14
b.len <- 1
d <- d.length %>%
filter(species == i.species) %>%
transmute(
station = station,
vessel = vessel,
len = (floor(len/b.len)*b.len+b.len/2), # length grouping
catch = catch
) %>%
group_by(station, vessel, len) %>%
summarise(catch = sum(catch)) %>%
ungroup() %>%
complete(
len, # remove using full_seq()
station,
vessel,
fill = list(catch = 0),
) %>% # complete zero observations
inner_join( # add grouping index
d.length %>%
mutate(group = strat) %>%
distinct(station, group),
by = "station") %>%
mutate(station = factor(station),
vessel = factor(vessel),
group = as.integer(factor(group)))
# length at center of each bin, vector for plotting
# lenseq <- full_seq(d$len, b.len)
lenseq <- unique(d$len)
# data for offset: same within a tow
# use zeros as this data is tow-standardized
d.offset <- d %>%
distinct(station) %>%
mutate(offset = 0)
# basis and penalty matrices for cubic spline
# over length bins
# location of knots might influence smooth functions (and convergence)
# default to 10 knots resulting in 2 fixed and 8 random effects
library(mgcv)
cs <- smooth.construct(
object = s(len, bs = "cr"),
data = d %>% group_by(len) %>% summarise(catch = sum()),
knots = NULL
)
# cs <- smooth.construct(
#     object = s(len, bs = "cr", k = 6),
#     data = d %>% group_by(len) %>% summarise(catch = sum()),
#     knots =  list(len = seq(min(lenseq),max(lenseq),length.out = 6)))
n_f <- 2
n_r <- cs$df - n_f
eigende <- eigen(cs$S[[1]])
# run TMB model
library(TMB)
version <- "test_groupbetabinom"
compile(paste0(version,".cpp"))
dyn.load(dynlib(version))
# input for TMB
nlen = length(lenseq)
nstation = nlevels(d$station)
nind = n_distinct(d$group)
data = list(
A = d %>% filter(vessel == "NED") %>% spread(len, catch) %>% select(-station, -vessel, -group) %>% as.matrix(),
B = d %>% filter(vessel == "TEL") %>% spread(len, catch) %>% select(-station, -vessel, -group) %>% as.matrix(),
offset = outer(d.offset$offset,rep(1,length(lenseq))),
Xf = cs$X %*% eigende$vectors[,1:n_f+n_r],
Xr = cs$X %*% eigende$vectors[,1:n_r],
d = eigende$value[1:n_r],
ind = distinct(d, station, group)$group,
n_ind = nind
)
parameters = list(
beta = rep(0, n_f),
b = rep(0, n_r),
gamma = rep(0, n_f),
g = rep(0, n_r),
delta = matrix(0, nind, n_f),
epsilon = matrix(0, nind, n_r),
log_s_b = log(10),
log_s_g = log(10),
log_s_epsilon = log(10),
chol_delta = c(1,0,1) # use chol decomp in vector form
)
map <- list()
obj = MakeADFun(data=data,
parameters=parameters,
map=map,
DLL=version,
random = c("b", "g", "delta", "epsilon"),
silent = F)
opt <- nlminb(obj$par,obj$fn,obj$gr)
i.model <- "GB"
# check convergence, maximum gradient and positive definite
if(exists("opt")){
if(!opt$convergence){
gra <- obj$gr()
hes <- eigen(optimHess(par=opt$par, fn=obj$fn, gr=obj$gr))$values
if(max(abs(gra)) < 0.1 & min(hes) > -0.1){
aic <- 2*sum(obj$report()$nll) + 2*10
rep <- try(sdreport(obj))
res <- list(obj = obj, opt = opt, aic = aic, gra = gra, hes = hes)
save(res, file = paste0("beta-binom-gr/NED2005/", i.species, "-",i.model,".rda"))
}
opt
nstation
# #########################################
# test beta binomial model with subgrouping
# #########################################
rm(list = ls())
setwd("C:/Users/yinyi/Dropbox/BIO/Comparative_Fishing/Workspace/betabinom_gam/")
library(dplyr)
library(tidyr)
library(ggplot2)
load("../read_data/data-NED2005.RData")
# organize data for model
i.species <- 23
b.len <- 1
d <- d.length %>%
filter(species == i.species) %>%
transmute(
station = station,
vessel = vessel,
len = (floor(len/b.len)*b.len+b.len/2), # length grouping
catch = catch
) %>%
group_by(station, vessel, len) %>%
summarise(catch = sum(catch)) %>%
ungroup() %>%
complete(
len, # remove using full_seq()
station,
vessel,
fill = list(catch = 0),
) %>% # complete zero observations
inner_join( # add grouping index
d.length %>%
mutate(group = strat) %>%
distinct(station, group),
by = "station") %>%
mutate(station = factor(station),
vessel = factor(vessel),
group = as.integer(factor(group)))
# length at center of each bin, vector for plotting
# lenseq <- full_seq(d$len, b.len)
lenseq <- unique(d$len)
# data for offset: same within a tow
# use zeros as this data is tow-standardized
d.offset <- d %>%
distinct(station) %>%
mutate(offset = 0)
# basis and penalty matrices for cubic spline
# over length bins
# location of knots might influence smooth functions (and convergence)
# default to 10 knots resulting in 2 fixed and 8 random effects
library(mgcv)
cs <- smooth.construct(
object = s(len, bs = "cr"),
data = d %>% group_by(len) %>% summarise(catch = sum()),
knots = NULL
)
# cs <- smooth.construct(
#     object = s(len, bs = "cr", k = 6),
#     data = d %>% group_by(len) %>% summarise(catch = sum()),
#     knots =  list(len = seq(min(lenseq),max(lenseq),length.out = 6)))
n_f <- 2
n_r <- cs$df - n_f
eigende <- eigen(cs$S[[1]])
# run TMB model
library(TMB)
version <- "test_groupbetabinom"
compile(paste0(version,".cpp"))
dyn.load(dynlib(version))
# input for TMB
nlen = length(lenseq)
nstation = nlevels(d$station)
nind = n_distinct(d$group)
data = list(
A = d %>% filter(vessel == "NED") %>% spread(len, catch) %>% select(-station, -vessel, -group) %>% as.matrix(),
B = d %>% filter(vessel == "TEL") %>% spread(len, catch) %>% select(-station, -vessel, -group) %>% as.matrix(),
offset = outer(d.offset$offset,rep(1,length(lenseq))),
Xf = cs$X %*% eigende$vectors[,1:n_f+n_r],
Xr = cs$X %*% eigende$vectors[,1:n_r],
d = eigende$value[1:n_r],
ind = distinct(d, station, group)$group,
n_ind = nind
)
parameters = list(
beta = rep(0, n_f),
b = rep(0, n_r),
gamma = rep(0, n_f),
g = rep(0, n_r),
delta = matrix(0, nind, n_f),
epsilon = matrix(0, nind, n_r),
log_s_b = log(10),
log_s_g = log(10),
log_s_epsilon = log(10),
chol_delta = c(1,0,1) # use chol decomp in vector form
)
map <- list()
obj = MakeADFun(data=data,
parameters=parameters,
map=map,
DLL=version,
random = c("b", "g", "delta", "epsilon"),
silent = F)
opt <- nlminb(obj$par,obj$fn,obj$gr)
i.model <- "GB"
# check convergence, maximum gradient and positive definite
if(exists("opt")){
if(!opt$convergence){
gra <- obj$gr()
hes <- eigen(optimHess(par=opt$par, fn=obj$fn, gr=obj$gr))$values
if(max(abs(gra)) < 0.1 & min(hes) > -0.1){
aic <- 2*sum(obj$report()$nll) + 2*10
rep <- try(sdreport(obj))
res <- list(obj = obj, opt = opt, aic = aic, gra = gra, hes = hes)
save(res, file = paste0("beta-binom-gr/NED2005/", i.species, "-",i.model,".rda"))
}
# #########################################
# test beta binomial model with subgrouping
# #########################################
rm(list = ls())
setwd("C:/Users/yinyi/Dropbox/BIO/Comparative_Fishing/Workspace/betabinom_gam/")
library(dplyr)
library(tidyr)
library(ggplot2)
load("../read_data/data-NED2005.RData")
# organize data for model
i.species <- 201
b.len <- 1
d <- d.length %>%
filter(species == i.species) %>%
transmute(
station = station,
vessel = vessel,
len = (floor(len/b.len)*b.len+b.len/2), # length grouping
catch = catch
) %>%
group_by(station, vessel, len) %>%
summarise(catch = sum(catch)) %>%
ungroup() %>%
complete(
len, # remove using full_seq()
station,
vessel,
fill = list(catch = 0),
) %>% # complete zero observations
inner_join( # add grouping index
d.length %>%
mutate(group = strat) %>%
distinct(station, group),
by = "station") %>%
mutate(station = factor(station),
vessel = factor(vessel),
group = as.integer(factor(group)))
# length at center of each bin, vector for plotting
# lenseq <- full_seq(d$len, b.len)
lenseq <- unique(d$len)
# data for offset: same within a tow
# use zeros as this data is tow-standardized
d.offset <- d %>%
distinct(station) %>%
mutate(offset = 0)
# basis and penalty matrices for cubic spline
# over length bins
# location of knots might influence smooth functions (and convergence)
# default to 10 knots resulting in 2 fixed and 8 random effects
library(mgcv)
cs <- smooth.construct(
object = s(len, bs = "cr"),
data = d %>% group_by(len) %>% summarise(catch = sum()),
knots = NULL
)
# cs <- smooth.construct(
#     object = s(len, bs = "cr", k = 6),
#     data = d %>% group_by(len) %>% summarise(catch = sum()),
#     knots =  list(len = seq(min(lenseq),max(lenseq),length.out = 6)))
n_f <- 2
n_r <- cs$df - n_f
eigende <- eigen(cs$S[[1]])
# run TMB model
library(TMB)
version <- "test_groupbetabinom"
compile(paste0(version,".cpp"))
dyn.load(dynlib(version))
# input for TMB
nlen = length(lenseq)
nstation = nlevels(d$station)
nind = n_distinct(d$group)
data = list(
A = d %>% filter(vessel == "NED") %>% spread(len, catch) %>% select(-station, -vessel, -group) %>% as.matrix(),
B = d %>% filter(vessel == "TEL") %>% spread(len, catch) %>% select(-station, -vessel, -group) %>% as.matrix(),
offset = outer(d.offset$offset,rep(1,length(lenseq))),
Xf = cs$X %*% eigende$vectors[,1:n_f+n_r],
Xr = cs$X %*% eigende$vectors[,1:n_r],
d = eigende$value[1:n_r],
ind = distinct(d, station, group)$group,
n_ind = nind
)
parameters = list(
beta = rep(0, n_f),
b = rep(0, n_r),
gamma = rep(0, n_f),
g = rep(0, n_r),
delta = matrix(0, nind, n_f),
epsilon = matrix(0, nind, n_r),
log_s_b = log(10),
log_s_g = log(10),
log_s_epsilon = log(10),
chol_delta = c(1,0,1) # use chol decomp in vector form
)
map <- list()
obj = MakeADFun(data=data,
parameters=parameters,
map=map,
DLL=version,
random = c("b", "g", "delta", "epsilon"),
silent = F)
opt <- nlminb(obj$par,obj$fn,obj$gr)
i.model <- "GB"
# check convergence, maximum gradient and positive definite
if(exists("opt")){
if(!opt$convergence){
gra <- obj$gr()
hes <- eigen(optimHess(par=opt$par, fn=obj$fn, gr=obj$gr))$values
if(max(abs(gra)) < 0.1 & min(hes) > -0.1){
aic <- 2*sum(obj$report()$nll) + 2*10
rep <- try(sdreport(obj))
res <- list(obj = obj, opt = opt, aic = aic, gra = gra, hes = hes)
save(res, file = paste0("beta-binom-gr/NED2005/", i.species, "-",i.model,".rda"))
}
# #########################################
# test beta binomial model with subgrouping
# #########################################
rm(list = ls())
setwd("C:/Users/yinyi/Dropbox/BIO/Comparative_Fishing/Workspace/betabinom_gam/")
library(dplyr)
library(tidyr)
library(ggplot2)
load("../read_data/data-NED2005.RData")
# organize data for model
i.species <- 204
b.len <- 1
d <- d.length %>%
filter(species == i.species) %>%
transmute(
station = station,
vessel = vessel,
len = (floor(len/b.len)*b.len+b.len/2), # length grouping
catch = catch
) %>%
group_by(station, vessel, len) %>%
summarise(catch = sum(catch)) %>%
ungroup() %>%
complete(
len, # remove using full_seq()
station,
vessel,
fill = list(catch = 0),
) %>% # complete zero observations
inner_join( # add grouping index
d.length %>%
mutate(group = strat) %>%
distinct(station, group),
by = "station") %>%
mutate(station = factor(station),
vessel = factor(vessel),
group = as.integer(factor(group)))
# length at center of each bin, vector for plotting
# lenseq <- full_seq(d$len, b.len)
lenseq <- unique(d$len)
# data for offset: same within a tow
# use zeros as this data is tow-standardized
d.offset <- d %>%
distinct(station) %>%
mutate(offset = 0)
# basis and penalty matrices for cubic spline
# over length bins
# location of knots might influence smooth functions (and convergence)
# default to 10 knots resulting in 2 fixed and 8 random effects
library(mgcv)
cs <- smooth.construct(
object = s(len, bs = "cr"),
data = d %>% group_by(len) %>% summarise(catch = sum()),
knots = NULL
)
# cs <- smooth.construct(
#     object = s(len, bs = "cr", k = 6),
#     data = d %>% group_by(len) %>% summarise(catch = sum()),
#     knots =  list(len = seq(min(lenseq),max(lenseq),length.out = 6)))
n_f <- 2
n_r <- cs$df - n_f
eigende <- eigen(cs$S[[1]])
# run TMB model
library(TMB)
version <- "test_groupbetabinom"
compile(paste0(version,".cpp"))
dyn.load(dynlib(version))
# input for TMB
nlen = length(lenseq)
nstation = nlevels(d$station)
nind = n_distinct(d$group)
data = list(
A = d %>% filter(vessel == "NED") %>% spread(len, catch) %>% select(-station, -vessel, -group) %>% as.matrix(),
B = d %>% filter(vessel == "TEL") %>% spread(len, catch) %>% select(-station, -vessel, -group) %>% as.matrix(),
offset = outer(d.offset$offset,rep(1,length(lenseq))),
Xf = cs$X %*% eigende$vectors[,1:n_f+n_r],
Xr = cs$X %*% eigende$vectors[,1:n_r],
d = eigende$value[1:n_r],
ind = distinct(d, station, group)$group,
n_ind = nind
)
parameters = list(
beta = rep(0, n_f),
b = rep(0, n_r),
gamma = rep(0, n_f),
g = rep(0, n_r),
delta = matrix(0, nind, n_f),
epsilon = matrix(0, nind, n_r),
log_s_b = log(10),
log_s_g = log(10),
log_s_epsilon = log(10),
chol_delta = c(1,0,1) # use chol decomp in vector form
)
map <- list()
obj = MakeADFun(data=data,
parameters=parameters,
map=map,
DLL=version,
random = c("b", "g", "delta", "epsilon"),
silent = F)
opt <- nlminb(obj$par,obj$fn,obj$gr)
i.model <- "GB"
# check convergence, maximum gradient and positive definite
if(exists("opt")){
if(!opt$convergence){
gra <- obj$gr()
hes <- eigen(optimHess(par=opt$par, fn=obj$fn, gr=obj$gr))$values
if(max(abs(gra)) < 0.1 & min(hes) > -0.1){
aic <- 2*sum(obj$report()$nll) + 2*10
rep <- try(sdreport(obj))
res <- list(obj = obj, opt = opt, aic = aic, gra = gra, hes = hes)
save(res, file = paste0("beta-binom-gr/NED2005/", i.species, "-",i.model,".rda"))
}
rm(list = ls())
setwd("C:/Users/yinyi/Dropbox/BIO/Comparative_Fishing/Workspace/binom_length_models/")
rm(list = ls())
setwd("C:/Users/yinyi/Dropbox/BIO/Comparative_Fishing/Workspace/length_binom_models/")
# AIC table
species_vec <- c(10, 11, 23, 14, 201, 204)
model_vec <- c(paste0("BB", 0:7),paste0("BI", 0:4), paste0("ZB", 2:3))
aic_mat <- matrix(NA, length(species_vec), length(model_vec), dimnames = list(species_vec, model_vec))
for(i.species in 1:length(species_vec)){
for(i.model in 1:length(model_vec)){
res_file <- paste0("res/", species_vec[i.species], "-",model_vec[i.model],".rda")
if(file.exists(res_file)){
load(res_file)
aic_mat[i.species, i.model] <- res$aic
rm("res", "res_file")
}
# AIC table
species_vec <- c(10, 11, 23, 14, 201, 204)
model_vec <- c(paste0("BB", 0:7),paste0("BI", 0:4), paste0("ZB", 2:3), "GB")
aic_mat <- matrix(NA, length(species_vec), length(model_vec), dimnames = list(species_vec, model_vec))
for(i.species in 1:length(species_vec)){
for(i.model in 1:length(model_vec)){
res_file <- paste0("res/", species_vec[i.species], "-",model_vec[i.model],".rda")
if(file.exists(res_file)){
load(res_file)
aic_mat[i.species, i.model] <- res$aic
rm("res", "res_file")
}
t(round(aic_mat - apply(aic_mat, MARGIN = 1, FUN = function(x) min(x, na.rm = T)), digits = 0)) %>%
write.table(file = "aic_table.txt")
aic_mat
res_file
file.exists(res_file)
species_vec <- c(10, 11, 23, 14, 201, 204)
model_vec <- c(paste0("BB", 0:7),paste0("BI", 0:4), paste0("ZB", 2:3), "GB")
aic_mat <- matrix(NA, length(species_vec), length(model_vec), dimnames = list(species_vec, model_vec))
for(i.species in 1:length(species_vec)){
for(i.model in 1:length(model_vec)){
res_file <- paste0("NED2005/", species_vec[i.species], "-",model_vec[i.model],".rda")
if(file.exists(res_file)){
load(res_file)
aic_mat[i.species, i.model] <- res$aic
rm("res", "res_file")
}
aic_mat
t(round(aic_mat - apply(aic_mat, MARGIN = 1, FUN = function(x) min(x, na.rm = T)), digits = 0)) %>%
write.table(file = "aic_table.txt")
t(round(aic_mat - apply(aic_mat, MARGIN = 1, FUN = function(x) min(x, na.rm = T)), digits = 0))
t(round(aic_mat - apply(aic_mat, MARGIN = 1, FUN = function(x) min(x, na.rm = T)), digits = 0)) %>%
write.table(file = "aic_table.txt", sep = "\t")
t(round(aic_mat - apply(aic_mat, MARGIN = 1, FUN = function(x) min(x, na.rm = T)), digits = 0)) %>%
write.table(file = "aic_table.txt", sep = ";")
t(round(aic_mat - apply(aic_mat, MARGIN = 1, FUN = function(x) min(x, na.rm = T)), digits = 0)) %>%
write.table(file = "aic_table.txt", sep = "\t")
t(round(aic_mat - apply(aic_mat, MARGIN = 1, FUN = function(x) min(x, na.rm = T)), digits = 0)) %>%
write.table(file = "aic_table.txt", sep = ";")
t(round(aic_mat - apply(aic_mat, MARGIN = 1, FUN = function(x) min(x, na.rm = T)), digits = 0)) %>%
write.table(file = "aic_table.txt", sep = "\t")
t(round(aic_mat - apply(aic_mat, MARGIN = 1, FUN = function(x) min(x, na.rm = T)), digits = 0)) %>%
write.table(file = "aic_table.csv", sep = "\t")
t(round(aic_mat - apply(aic_mat, MARGIN = 1, FUN = function(x) min(x, na.rm = T)), digits = 0)) %>%
write.table(file = "aic_table.csv")
t(round(aic_mat - apply(aic_mat, MARGIN = 1, FUN = function(x) min(x, na.rm = T)), digits = 0)) %>%
write.csv(file = "aic_table.csv")
